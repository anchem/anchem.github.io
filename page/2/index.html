<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Still Waters</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Still Waters">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Still Waters">
<meta property="og:locale" content="zh">
<meta property="article:author" content="LiAng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Still Waters" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Still Waters</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016-01-28-new-year-2016" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/01/2016-01-28-new-year-2016/" class="article-date">
  <time datetime="2020-02-01T02:50:13.846Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/01/2016-01-28-new-year-2016/">2016年初念想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有3个月没写东西了，脑子都有点生锈了。刚过完24岁生日，迎来了新的一年，最近也发生了不少事情，正好写一写吧。<br>2015年的最后一个月，我是在压力和期待中度过的，说起来还是挺充实的，也挺快乐的。当时主要在忙导师和公司合作的项目，于我而言就是用go语言设计和实现一个流程引擎平台，支持智能车库这样一个应用场景，面向北美的用户提供服务。选择go语言是看中了它的并发性能，当然，我认为还需要进行压力测试才能检验出来它到底行不行。期间好几个周末都没有休息，开会的频率基本上一两天一次，晚上11点多回宿舍，嗯，早上自然会多睡会儿。当时提出来流程引擎在物联网的应用时，我思考了一番，因为我正巧有想做智能家居、智能硬件的想法，我觉得流程引擎，还有我们实验室另一个研究方向，消息中间件，在物联网的应用价值，都特别大。所以，做这样一个项目，我也是非常有兴趣的，虽然看起来挺累，一天到晚坐在电脑前设计架构、敲代码实现、测试bug，但是我挺有动力，一点不觉得这是件苦差事或者很无聊，至少比同院那些一天到晚替导师跑腿的好太多了。<br>不过天天都在搞项目，生活还是有些乏味，唯一期待的事情，就是要和老婆去云南旅游。这件事从9月份就开始策划了，10月份给导师请的假提前订好了机票，感觉这几个月，都在期待中度过，也算是给平淡的生活，增添了不少乐趣。这次旅游，我们去了昆明、丽江和泸沽湖，在泸沽湖呆了3天，又爬了玉龙雪山。旅游是有苦有乐的。苦的是赶路，飞机、火车、汽车全坐了个遍，大部分时间都在路上，而且往返泸沽湖的路是又远又破，上上下下山路十八弯。吃东西多了怕吐，不吃又晕，还好贴了晕车贴，还算挺管用的，这飞机、汽车一个都没晕。乐的就多啦，不然干嘛出去受罪呀。首先跟老婆一学期没见了，自然是想念的很，能一起出去旅游，看看美景，尝尝美食，呆一呆，多幸福啊；其次啊，先说美景好呢还是先说美食好呢？看到泸沽湖的时候，坐车的疲惫感立马就抛到九霄云外了！尝到藏式牦牛肉火锅的时候，饿了大半天都觉得真值啊！我觉得这一路上最美的景色，一个是泸沽湖的湖水，碧蓝清澈，一个是泸沽湖夜晚的星空，真的是群星璀璨，还有一个，就是玉龙雪山，圣洁干净。这一路的美食也不少，从大众点评上看了几家评价非常好的餐厅，吃了过桥米线、烤鱼、烤肉、烤乳猪、烤牦牛肉、梅子酒、纯正的西藏牦牛肉火锅等等，不得不说，美食是绝对不可错过的呀。<br>旅游回来后又继续开始了学校的忙碌生活，直到过生日那几天，我给导师请了个假，因为老婆亲自跑来给我过生日啦，我要好好陪陪她。当然，我们开明的导师也准了假，从这一点上说，他还是相当棒的。那几日自然很快乐，老婆亲手做了生日蛋糕给我助兴，还做了超级好吃的花生小小酥做平常的甜点，有这么一个温柔贤惠的老婆，我是三生有幸呀。<br>24岁一过，就觉得自己和以往不同了，我要开始建设自己的小家，开始认真考虑和规划自己的生活和事业，开始多和自己的父母保持沟通等等。会觉得有很多想要做的事情，也有很多必要做的事情，还有一些对内心更深层次的探索和对生活和世界的深入理解。感觉自己更有内在驱动力和自控力了，变得更勤快了，思考和做事情也少了许多浮躁，多了一些考虑、理解和包容。我想这些都是成长，相比以前的自己，我变得更好了，而且，我会越来越好的。<br>快过年了，虽然这是一个热闹的节日，我倒想利用过年回家的时间，好好沉静一下，为生活，辞旧迎新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/01/2016-01-28-new-year-2016/" data-id="ck630batg0003vchlbw7t5zmq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-09-26-professor-xie-fei-feelings" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/01/2015-09-26-professor-xie-fei-feelings/" class="article-date">
  <time datetime="2020-02-01T02:50:13.839Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/01/2015-09-26-professor-xie-fei-feelings/">听一次讲座有感</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周的周二到周五，有幸聆听了来自Portland State University计算机学院的XieFei教授的讲座，真是收获良多，颇受振奋啊。<br>这四天的讲座，每天都以一篇独立的博士论文为材料，介绍了软件工程方面的一些问题和解决办法。每天的讲解都以motivation开始，告诉我们为什么要解决这样一个问题，然后介绍解决的办法，最后得出结论以及效果如何，对未来应用的展望等。XieFei教授的讲解深入浅出，通俗易懂，而且互动性特别好，常常一针见血，给我的启发特别多。如果说我目前处于Level 2 的层次，那他就是在Level 4的层次在向我展示他们的成果，同时也会向我们介绍Level 6层次的人在做什么，为什么他们能领先我们那么多，为什么他们有那么高的价值，<br>先从这四篇论文说起吧。   </p>
<ol>
<li><strong>Automate-Theoretic Approach to Hardware/Software Co-verification</strong><br>简单说就是软硬件的协同验证。我们知道一个操作系统，除了内核kernel部分，有绝大部分都是各种各样的driver。windows xp有超过35000个driver，linux有70%都是driver，系统软件开发大多也是在做driver，真正动kernel的很少。用过win xp或者更早的操作系统的人，一定见过蓝屏死机，为啥呢？它就是在软硬件交互的时候（devices and device drivers）出的错，大概有52%的crash都是在软硬件交互的时候发生的。为了进行有效的软硬件协同认证，这里引入了formal specification和model checking的方法。但是在使用这些方法的时候，我们会面临三个问题：缺少形式化描述（通常使用英语来描述接口协议，但英语作为自然语言没有形式化定义），缺少一个统一正式的软硬件接口（软件是一个下推自动机，而硬件是有限自动机），缺少验证工具。这篇论文就针对这些问题，提出了一种合理且有效的解决方案，并且已经被应用到了工业界。<br>他们做的这个验证工具，在生产过程中，可以直接减掉一个环节的人工成本（雇佣一个工程师的价格是一年20万美金，而一个工具，显然要便宜的多），并且还能提高验证的正确率，这对老板来说可是一个不小的诱惑。而在IT界，有很多人就在做这样的工具，让工具来替代人的工作。工具可以一天24小时运转，工具不会有情绪，不会因为情感的波动而出错。这是一个好消息，也是一个坏消息。假如你不幸的被这种工具替代了，要么失业，要么学别的东西吧。所以，做对别人来说有用的工具，是非常有意义的一件事。（为什么图灵问题一直都不可解？图灵问题要是解决了，咱这做软件工程师的，可就都要失业喽。也正是因为如此，我们才有饭碗，我们才有工作去做）</li>
<li><strong>Scalable Equivalence Checking for Behavioral Synthesis</strong><br>在上个世纪的时候，硬件电路是手工画出来的，然后再拿去制作。后来引入了硬件描述语言HDL、VHDL，用它设计出来的硬件电路可以实现更高数量级的逻辑门的设计，这使得我们手边的笔记本电脑成为了现实。在从HDL到硬件电路的实现过程中（也叫逻辑综合），形式化验证方法起到了至关重要的作用，可以说这是它在工业界取得的一次巨大成就。随着工业界需求的不断升级，硬件电路的设计继续向上发展，出现了行为级，也就是软件级别的硬件电路设计。这样使得硬件电路的设计形成这样的模式，先由软件级别的语言来设计，然后生成硬件描述语言HDL（这个过程叫行为综合），然后再生成实际的硬件电路（即逻辑综合）。而这里就会出现一个问题，由高级语言设计硬件电路，通过编译器向HDL转换的过程中，是否等价？如果这里不等价的话，那么设计出来的错误的硬件电路在工厂里会以一夜几万块的数量生产出来。所以这个工作既重要又有必要。<br>文章里实现的方法是Clocked Control/Data Flow Graph，它使用我们都熟知的流程图，只不过在上面加上了时钟单元，这样就把行为综合和逻辑综合统一了起来。同时要检测由行为级生成的逻辑级的HDL语言是否一一对应（就像软件编译一样，中间会有很多步骤，每一步都会生成不同的中间代码），如果每一步的结果都进行检测，那么这部分工作会变得异常庞大而且耗时耗力，这会导致这种检测失去了它的意义。而使用一个简单的方法，我们就能让它运作起来，而且我们都学过这种方法，它就是数学归纳法。我不用判断g(0)和g(1),g(1)和g(2)，一直到g(k-1)和g(k)是否等价，我们只用判断进入状态是等价的，结果是等价的，就能够保证，每一步的转换都是等价的。我们不用证明是否正确，我们只用证明转换前的版本和转换后的版本是等价的就可以。这个过程可以直接由符号执行去做，大大提高了检测的效率。</li>
<li><strong>Post-silicon Functional Validation with Virtual Prototypes</strong><br>一般公司在做一个产品的时候，一般会先做硬件，然后再开发软件，开发过程是顺序进行的。后来呢，在硬件开发和软件开发之间加入了虚拟机，在硬件开发到一定程度的时候，软件开发就可以在虚拟机上同时进行了，这样大大减少了开发时间，缩短了开发周期。但是如何保证这个虚拟机和硬件是一致的，也就是在虚拟机上测试通过的测试例，可以在真实的硬件上同样通过测试。那么这篇论文就提出了一种方法，concrete execution和symbolic execution结合的方式。可惜我对这些方法还都不太懂，所以我也没法具体介绍，论文里都有详细的阐述。<br>在教授介绍这篇论文的时候，他一再强调，我们做软件工程的人，很有必要去借鉴那些做系统的人的方法。比如他们仅仅用了六个函数就把硬件电路的模型给描述了出来，抽象的能力相当的强。最近我在看CSAPP（《Computer Systems A Programmer’s Perspective》）的时候，书中也强调了“The use of abstractions is one of the most important concepts in computer science.”我想这一点，的确值得我们好好思考。</li>
<li><strong>Automatic Fault Injection for Driver Robustness Testing</strong><br>先来看一个driver调用kerner APIs的实际代码吧<br><code>int *p = (int *)kmalloc(size,GFP_ATOMIC);</code><br><code>p[10] = 3;</code><br>问题很明显，即使是调用操作系统内核的API，也有可能会返回一个未知状态的指针。<br><code>int *p = (int *)kmalloc(size,GFP_ATOMIC);</code><br><code>if(!p) goto error;</code><br><code>p[10] = 3;</code><br><code>......</code><br><code>error : error_handler();</code><br>这样怎么样？好一些了吧？其实，这只是把bug推到了后面而已。<br>这就是这篇论文要解决的问题。操作系统的driver大多都是第三方写的，driver在调用系统API的时候都会默认不会产生bug，可kernel的API也是人写的，谁能保证一定不会出bug呢？那么，出了问题怎么办？我们能否在测试的时候，就找到driver的这些错误，而不去更改kernel的代码？<br>这篇论文就针对这个问题提出了一种fault injection的方法来检测错误。它是将kernel的内核包装了一下，在其中加入了一些错误，尤其是调用跟内存有关的函数的时候。这样，当driver调用kernel APIs的时候，如果出现了错误而driver没有做错误检测，就能通过测试例发现这些bug。这种方法不需要去修改测试例，不需要修改kernel内核，就可以发现driver里的bug。测试的结果也显示，目前广泛使用的很多driver都被检测出了bug，这是一个相当有意义的事情。   </li>
</ol>
<p>这些论文在网上都可以搜到，别忘了强大的google，我个人的建议是能不用百度就不用百度，毕竟搜出来的东西，经常很难让人满意，容易浪费时间。说到这儿，教授提到说，在这个时代，信息是一个非常非常重要的资源，你获得了信息，你就获得了机会，如果你没有足够的信息，很多机会你都看不到。但也并不是所有信息对自己来说都是有用的，也有很多无用的垃圾信息，鉴别和保持清醒同样重要。<br>同时，教授还提到，保持一个open mind特别重要，如果有机会的话，多出去看看，多和人交流交流，不要把自己局限在一隅，不要给自己设限，自我定位不要太低，不要贱卖自己。这一点我也深有感受，自己对自己的认识和定位，决定了自己能达到的高度，如果连想都不敢想，那就永远都达不到。同时，和人交流也特别重要，我想这一点，每个和别人交流过的人，一定会体会到的，尤其是那些能给自己带来启发和营养的交流，绝对是“听君一席话，胜读十年书”。<br>此外，教授还说到一个关于学历和能力的关系，让我对它们的理解更深了一层。人为什么要上大学呢？教授的老板问了他一句话“Are you genius?”,如果是，那么大学没必要上；如果不是，那就去上，让自己去学习该有的能力。博士是干嘛呢？博士是发现问题（发现问题很重要），然后在发现问题的基础上，找到解决问题的办法。硕士是干嘛呢？硕士是在博士找到的解决办法上，在那个框架上，去具体的解决问题。学士干嘛呢？学士是把硕士的任务拿出来一个模块，解决这个模块里的问题，去实现这个模块。假如你具有了发现问题，解决问题的能力了，何必去花那个时间读博士呢？学历只是在找第一份工作的时候作为一个敲门砖，之后，一点用也没有。facebook等很多公司，直接雇佣美国的高中生，为什么？因为他们有这种能力，根本不需要更高的学历。反而，有很多博士，读出来却没有这种能力，那么他会跌的很惨。在企业里，为什么有人一年能拿200万，有人只能拿20万？因为他有那个能力去拿200万，能为企业带来效益，他就能解决你解决不了的问题。在软件界，优秀的程序员和很水的程序员的生产力可以差好几个数量级，你拿20个水程序员也比不过一个优秀的程序员，反而很水的程序员不是在贡献，而是在引入bug，然后修改自己引入的bug，这样一年还能拿20万的薪水，已经相当给面子了。所以，提升自己的能力，永远都是金钥匙。<br>对我自己来说，听完教授的这些讲座，收获和振奋是相当多的。我发现了自己不够专注的问题，不能专注认真的做好当下手头的事情，不能专注的去学习一个东西，而是既想学这，又想学那个，有时候又容易被别的事情分心。这对我最后一年的研究生生涯来说，至关重要。同时，我还意识到了motivation的重要性。不管做什么事情，一定要找到充分的理由去做这件事，这既是动力，也是它的意义所在。例如要做一个工具，结果并没有人需要用它，那么做这个工具这件事就完全没有意义。比如要解决一个问题，在工业界的确有能用到的地方，而且很需要它的解决方案，那么这件事就具备了充分的motivation。包括我在介绍这四篇论文的时候，也仅仅是描述了一下motivation，当motivation具备了之后，人自然就会想去了解具体内容是什么了。   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/01/2015-09-26-professor-xie-fei-feelings/" data-id="ck630batb0001vchlf8vnc7zc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-08-24-internshipfeelings" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/01/2015-08-24-internshipfeelings/" class="article-date">
  <time datetime="2020-02-01T02:50:13.832Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/01/2015-08-24-internshipfeelings/">实习感想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>研一的暑假，有幸和教研室的同窗们来深圳一家做物联的公司实习20天，时间虽然不长，但收获却不少。平日我们都局限在学校这个小环境里，难得有这么一个机会进到IT行业的第一线公司，身临其境地体验工作环境，也感谢老师给我们这个机会。<br>公司不大，60多个人，给我们几个研究生的待遇非常好，住的7天酒店，有免费早餐，报销来回路费，还有实习工资的补助。不得不说，公司的确很重视我们，毕竟我们是他们接受的第一届研究生的实习生。不管是余总的叮嘱，王总的安排，还是lolo姐的照顾，以及公司里热心帮忙的大哥们，哦对，还有服务下午茶和教我们午间操的前台妹妹，都给我留下了很深的印象。这20多天过的很充实，也很快乐。<br>正好我的舅舅也在深圳，他们热情的欢迎我来这里，带我和他们一家三口去西涌沙滩玩，还请我吃了顿大餐接风洗尘。我也非常感谢他们对我的照顾和关心，在我心里面，我一直把他们当亲舅舅来看，虽然他们不是。<br>同时，这段时间，我也反思了很多事情。只有反思和总结，人才会进步。<br>在此，我分享和记录一下这段时间的感想，想到哪里写到哪里，各部分独立，互不影响。</p>
<ul>
<li>第一次和负责研发的王总讨论问题的时候，我就发现了这么一个事情：人家是做软件的，我们是闹着玩的。论研究，一个MQTT协议，他们能考虑到这个协议的弊端，适用场景是否符合我们的需要，鼓吹的优点是不是真如所说那样，安全性怎么保障，以bit为单位的标志位和以byte为单位的标志位的特性对比等等；论工程，他们的接口定义清晰，设计严谨，分层明确，命名和注释规范，让人看了逻辑就清晰明白，讨论问题一针见血，不含糊，主动减少对方的误解，效率很高。反观我们，那简直就是，打酱油的。一问三不知，这也考虑不到那也考虑不到，被指出来了还觉得自己那样就挺好的，把问题拖延到以后再解决。缺乏经验和实践还能努力补上，思想的懒惰和逃避才是可怕的。</li>
<li>我们每个周末以及每天下班的晚上，我和我的小伙伴们吃完饭回到住处，或打开电脑，或打开手机，要么玩游戏，不管是电脑游戏还是手游，要么刷各种新闻知乎微博朋友圈空间等等；到了周末，有一天是去红树林，有一天是办银行卡，剩下的周末，中午睡到11点，起来吃个饭，下午打开电脑，除了玩游戏、看视频和刷信息，基本不干啥事儿。我很恶心天天玩游戏刷各种东西的生活，很多时候完全是无意识的和控制不了自己的，同时心里又清楚这样不好但又没办法改变。但是日子要是这么过下去，研究生生涯，甚至以后工作的几年，都会被荒废掉。那个时候，我一定会追悔莫及和骂自己的，就像我现在会骂自己高中为什么不努力学习一样。人不怕犯错，就怕两次都跌到同一条沟里，甚至还浑然不知。</li>
<li>表达能力很重要，表达能力很重要，表达能力很重要。重要的事情说三遍！有一天周末，我们学院的书记来视察了，跟我们一起开了个会，余总也参加了。虽然听他闲扯一堆乱七八糟的很无聊，但是让我们发言发表感想的时候，我很郁闷自己说了一坨翔。当然我觉得我们很多人说的，都是一坨翔。个人私下交流的时候，我们都能畅所欲言，表达我们所想。可是在公共场合发言的时候，我们都变成了不会说话的文盲。语言组织的乱七八糟，连词不成句，用词不准确，嗯嗯啊啊的支支吾吾，说话不具体，让人不知所云。一个人如果不能在多人场合顺畅准确的表达自己的思想，这在做很多事情的时候，都会成为一块巨大的绊脚石，摔的自己体无完肤，错过很多机会。</li>
<li>视野很重要，不管是思想上的，工作上的，还是生活上的。读万卷书，行万里路，阅人无数。天天在教研室这种小地方呆着，天天接触的就是那么几个人，天天接触的就是那么几件事，眼前盯的也就是那么一亩三分地，这不就像井底之蛙一样？一年之后就要在社会上打拼，现在却窝在这么一个小环境里，我真是深深的担忧和深深的恐惧。这一次来深圳，也终于有了机会和我舅舅交流，他在深圳20年了，自己创业白手起家，现在有一个很幸福的家庭和成长中的事业，从他那里，我受到了很多启发，原来社会上有些事情不是我想象的那般简单，原来有些事情还可以这么做，原来我一直以来对某件事的认识是错误的，等等。我还看到了，目前自己的状态，完全跟不上社会发展的节奏，这也是值得好好重视和调整的。</li>
<li>定期反思和总结比想象中的要重要，尤其是在我们现在身处的时代。我只说两点，一个是垃圾信息，一个是无意识行为。我们每天都在从各种媒体上获取各色各样的信息，不管是主动去刷的微博、朋友圈、新闻客户端，还是被动接收的推送、广告、消息。我们每天都会有意识或者无意识的花大量的时间在这上面，工作之余，路上，吃饭时间，甚至是和别人交谈的时候。有一天，我问了自己这么一个问题：我天天看了这么多信息，对我的生活有哪些影响？假如我不看这些信息了，我的生活又能受到多大的影响？答案让我的心中一定。首先花了那么多时间不说，人脑每天能够处理的信息量是有限的，过量的信息不会成为脂肪积累下来，只会变成垃圾被大脑遗忘或者干扰其他信息的获取。花时间做这样一件无意义的事情，简直是浪费生命。再说无意识的行为。吃饭的时候拿出来手机看，隔一会儿就要拿出来手机刷，打开电脑看到新闻广告一路就点进去忘记了时间，不知道干啥顺手打开游戏一玩就是一天，看视频也停不下来，睡前拿出手机刷刷再睡觉……这类事情熟悉吧，是有意识的么？很多时候都是无意识的，变成了习惯。习惯很有力量，习惯也很可怕。再算一算一天扔了多少时间在这些无意识的事情上面，后悔过没？想过去改变没？又能有意识的控制自己吗？不想在3,5年之后回忆起来说自己的青春都挥霍了，现在就好好反思反思吧。</li>
<li>想清楚，不管做什么事情，一定要想清楚，三思而后行。小到写代码，思路都没理清楚就急着去敲代码，质量不高也难以维护。大到人生，健康，家庭，工作，朋友，同事，这些生活的方方面面，哪些对我来说是特别重要的，哪些是次重要的，哪些是不重要的？这在我们做人生规划和决策的时候，就是衡量的标准。人生就是各种各样的选择，怎么去选，就看你看重的是什么，不看重的又是什么，能不能面对自己的内心去选择而不是别人的声音或者面子虚荣。希望我们都能在这珍贵的一生里，争取到我们想要的，扔掉我们不想要的。</li>
<li>舍得舍得，舍比得更重要。觉得自己想追寻的东西没时间做？玩游戏的时间太长？刷微博和新闻太浪费时间？你敢不敢把它们卸载了？舍掉这些，你就能有时间和精力去做你追寻的东西，你舍得的了不？我就把我ipod touch上每天都要玩的很耗时的游戏卸载了，每天必刷的手机新闻客户端卸载了，腾出来的时间陪女朋友和看自己喜欢的书，我觉得很值得。电脑用着用着发现编译速度太慢了，常常要等待程序编译完运行再测试，很花时间。舍得花钱买一个固态硬盘，再加个大内存吗？节省下来的时间绝对比花出去的钱要划算多了，工作效率得到了数量级的提升。节省下来的时间，不妨去锻炼一下身体，多好。</li>
<li>我觉得游戏这个东西，真的没有人生有意思。游戏里打怪升级，获得各种各样的道具勋章成就，对各个英雄研究的透透彻彻的，并且能熟练运用不同角色的技能获得胜利，然后得到一些奖励和回报。人生也是这样啊，只不过奖励和回报的冷却时间会长一些，努力之后获得结果的机率也比游戏低一些，因为人多且杂呀。人生的奖励和回报，可以是别人定义的，也可以是你自己定义的，这样看来，其实人生这场大“游戏”，我们是掌权的设计者和参与者而不是被动的玩家。而且我们可以获得的东西，比游戏里多的简直不是一个数量级，那种趣味，同样也不是一个数量级的。</li>
</ul>
<p>我们每个人最不缺的，就是大道理，指导起别人来头头是道，自己却过不好自己的生活。喜欢评论别人的生活，却不能踏踏实实的认真过好自己的生活。我想，最好的行动时间，一个是几年前，一个就是现在。与君共勉。   </p>
<blockquote>
<p>把握生命里的每一分钟，全力以赴我们心中的梦</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/01/2015-08-24-internshipfeelings/" data-id="ck630bate0002vchl3qnkauaf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-08-12-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/01/2015-08-12-hello-world/" class="article-date">
  <time datetime="2020-02-01T02:50:13.824Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/01/2015-08-12-hello-world/">my Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Hello World</p>
</blockquote>
<p>每个学过编程的人都知道<br>它是你手下第一个程序打印出来的问候<br>用新的语言向世界问好<br>同时它也是打开新世界的钥匙<br>这里<br>是我的世界<br>enjoy yourself !</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/01/2015-08-12-hello-world/" data-id="ck630bat00000vchlhoqbfqej" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-23-cyclomatic-complexity-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/01/2020-01-23-cyclomatic-complexity-in-c/" class="article-date">
  <time datetime="2020-02-01T02:50:13.817Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/01/2020-01-23-cyclomatic-complexity-in-c/">圈复杂度重构技术（C语言篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="圈复杂度"><a href="#圈复杂度" class="headerlink" title="圈复杂度"></a>圈复杂度</h2><h3 id="什么是圈复杂度"><a href="#什么是圈复杂度" class="headerlink" title="什么是圈复杂度"></a>什么是圈复杂度</h3><p><strong>圈复杂度（CC，Cyclomatic complexity）</strong>是一种代码复杂度的衡量标准，由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，目的是为了度量代码的复杂程度。</p>
<p>代码复杂度简单说是由独立的<strong>执行路径</strong>的条数决定，而执行路径的条数取决于<strong>判定节点</strong>的结构。</p>
<p>什么是判定节点呢，判定节点就是会根据逻辑表达式来选择后续执行哪条执行路径的节点，比如if语句，while语句，case语句，and和or语句，?:三元运算符等。</p>
<p>例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (i &lt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; do other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行的流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)----&gt;(2)----&gt;(4)----&gt;(5)</span><br><span class="line"> |               |</span><br><span class="line"> |-----&gt;(3)-----&gt;|</span><br></pre></td></tr></table></figure>
<p>从例1中可以看到，if语句作为一个判定节点（1），会带来2条独立的执行路径，一条执行判定结果为成立的（2），一条执行判定结果为不成立的（3），它们执行完毕后都会继续执行（4）</p>
<h3 id="为什么需要圈复杂度"><a href="#为什么需要圈复杂度" class="headerlink" title="为什么需要圈复杂度"></a>为什么需要圈复杂度</h3><p>之所以要度量代码的复杂程度是因为它和软件质量息息相关，主要表现在以下几个方面：</p>
<ol>
<li><strong>圈复杂度高的代码容易出现缺陷</strong></li>
<li><strong>圈复杂度高的代码不容易进行测试</strong></li>
<li><strong>圈复杂度过高往往其内聚性比较低</strong></li>
<li><strong>圈复杂度高的代码难以维护</strong></li>
</ol>
<p>所以我们往往会在持续集成的时候监控圈复杂度的大小，并且在必要的时候进行圈复杂度的清理，把它降到一个合适的范围。一般来说，圈复杂度在1-10是比较好的范围。</p>
<h3 id="如何计算圈复杂度"><a href="#如何计算圈复杂度" class="headerlink" title="如何计算圈复杂度"></a>如何计算圈复杂度</h3><p>计算公式</p>
<blockquote>
<p>V(G) = E - N + 2</p>
</blockquote>
<p>其中V(G)表示圈复杂度，E表示控制流图中边的数量，N表示节点的数量。</p>
<p>例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (i &lt; len) &#123;</span><br><span class="line">    if (a[i] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        printf(&quot;matched&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制流图简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)----&gt;(2)----&gt;(3)----&gt;(5)----&gt;(7)----&gt;(8)</span><br><span class="line"> |       |               |       |</span><br><span class="line"> |       |-----&gt;(4)-----&gt;|       |</span><br><span class="line"> |                               |</span><br><span class="line"> |&lt;------------(6)&lt;--------------|</span><br></pre></td></tr></table></figure>
<p>例2对应的这个控制流图里，边的数量有9条，节点8个，带入公式，V(G)=9-8+2=3</p>
<h2 id="降低圈复杂度–C语言"><a href="#降低圈复杂度–C语言" class="headerlink" title="降低圈复杂度–C语言"></a>降低圈复杂度–C语言</h2><h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><p>除了通过工具扫描之外，圈复杂度比较高的代码往往有一些明显的特征，它不像代码味道那样因人而异，所以比较容易识别。以下是一些常见的特征：</p>
<ul>
<li>在一个函数内部使用了很多if，while，for等判断语句；</li>
<li>嵌套了多层的条件判断或者循环语句；</li>
<li>函数内部的局部变量数量过多；</li>
<li>代码行数较长，比如超过了50行；</li>
</ul>
<h3 id="主要方法：提炼函数"><a href="#主要方法：提炼函数" class="headerlink" title="主要方法：提炼函数"></a>主要方法：提炼函数</h3><p><strong>提炼函数</strong>是最常用也是最主要的降圈方法，也是一种重要的重构方法，我们直接通过例子来说明：</p>
<p>例3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int ProcessData(Context context, int sid, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    Data data &#x3D; NULL;</span><br><span class="line">    if (context &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sid &lt;&#x3D; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (param &#x3D;&#x3D; NULL || param.errCode !&#x3D; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    data &#x3D; GetDataFromParam(param);</span><br><span class="line">    if (data-&gt;flag !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; some process ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; other process ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Log(INFO, &quot;the name of data is %s&quot;, data-&gt;name);</span><br><span class="line">    Log(INFO, &quot;the value of data is %s&quot;, data-&gt;value);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提炼之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Bool IsParamValid(Context context, int sid, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    if (context &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sid &lt;&#x3D; 0) &#123;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (param &#x3D;&#x3D; NULL || param.errCode !&#x3D; 0) &#123;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HandleDataProcess(Data data)</span><br><span class="line">&#123;</span><br><span class="line">    if (data-&gt;flag !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; some process ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; other process ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintDataDetail(Data data)</span><br><span class="line">&#123;</span><br><span class="line">    Log(INFO, &quot;the name of data is %s&quot;, data-&gt;name);</span><br><span class="line">    Log(INFO, &quot;the value of data is %s&quot;, data-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ProcessData(Context context, int sid, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    Data data &#x3D; NULL;</span><br><span class="line">    if (IsParamValid(context, sid, param) !&#x3D; TRUE) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    data &#x3D; GetDataFromParam(param);</span><br><span class="line">    if (data &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    HandleDataProcess(data);</span><br><span class="line">    PrintDataDetail(data);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例3所示原始的<strong>ProcessData</strong>函数里，我们看到圈复杂度较高，且整个函数做的事情有点多；在提炼之后，我们将功能相关的部分单独提炼出来了3个独立的函数，分别是<strong>IsParamValid</strong>，<strong>HandleDataProcess</strong>和<strong>PrintDataDetail</strong>，这样不仅每个函数的圈复杂度都不高，而且提炼后的代码逻辑更加清晰了。对于像<strong>PrintDataDetail</strong>之类的函数，还可以在其他函数里达到复用的效果。</p>
<p>对于提炼函数以及其他几种能够帮助降圈的方法，在《重构》这本书里你能找到更多更详尽解释和用法说明，我在这里就不再赘述了。</p>
<p>但我认为有两个关键点值得重复强调一下，那就是函数的命名和局部变量的修改。</p>
<p><strong>【函数命名】</strong><br>既然要提炼函数，那么提炼出来的函数肯定要有一个名字，而这个名字很重要，因为它会影响其他人怎么理解它。一个最普遍的做法就是按照它做了什么来命名，见名知意，达到自注释的效果。这样，上层函数读起来就跟读注释一样简单明了。</p>
<p><strong>【局部变量的修改】</strong><br>提炼函数往往伴随着局部变量的修改，这是该方法的难点，也是容易引入bug的地方，尤其是以下几个地方：</p>
<p><strong>====》</strong>如果存在仅用于被提炼出的函数的局部变量，那么就在提炼出的函数中声明并使用它，在原函数中移除掉；</p>
<p><strong>====》</strong>将被提炼代码中需要读取的局部变量作为参数传递进去；</p>
<p><strong>====》</strong>如果在被提炼代码中修改了声明在原函数中的局部变量，那么如果在被提炼的代码之后还在使用这个变量，要么通过返回值传递出来，要么传递变量的地址进去，利用语言出参数的特性带出来；如果之后不再使用这个变量，那么直接在提炼出的函数中使用即可；</p>
<p><strong>====》</strong>对于指向动态内存的局部变量，尽量在同一个函数内分配和释放，换句话说，如果在原函数中有这样的变量，那么建议不要在被提炼的函数中释放它，而应该在原函数中释放，这样有利于维护它的声明周期，避免内存泄露或重复释放等错误；</p>
<p>下面以一个例子来说明上述问题：<br>例4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int CountMatchedParam(Context context, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    Session session &#x3D; NULL;</span><br><span class="line">    Connection conn &#x3D; NULL;</span><br><span class="line">    unsigned int i &#x3D; 0;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Data* data &#x3D; NULL;</span><br><span class="line">    if (IsParamValid(context, prarm) !&#x3D; TRUE) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    conn &#x3D; GetConnection(context);</span><br><span class="line">    if (conn &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    session &#x3D; GetSessionFromConnection(conn);</span><br><span class="line">    if (session &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    data &#x3D; (Data*)MALLOC(sizeof(Data));</span><br><span class="line">    if (data &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    HandleExceptionMatch(session, param, &amp;count);</span><br><span class="line">    for (i &#x3D; 0; i &lt; param-&gt;len; i++) &#123;</span><br><span class="line">        if (param-&gt;arr[i] &#x3D;&#x3D; MATCH_FLAG) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        SAFE_FREE(data);</span><br><span class="line">        return -1</span><br><span class="line">    &#125;</span><br><span class="line">    HandleMatchedCount(param, data, count);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提炼后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Session GetSession(Context context) &#x2F;&#x2F; context作为入参传递进来</span><br><span class="line">&#123;</span><br><span class="line">    Connection conn &#x3D; NULL; &#x2F;&#x2F; 修改了声明的位置</span><br><span class="line">    Session session &#x3D; NULL;</span><br><span class="line">    conn &#x3D; GetConnection(context);</span><br><span class="line">    if (conn &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    session &#x3D; GetSessionFromConnection(conn);</span><br><span class="line">    return session; &#x2F;&#x2F; 作为返回值传递出来</span><br><span class="line">&#125;</span><br><span class="line">ErrCode MatchProcess(Param param, Data data, unsigned int count)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int i &#x3D; 0; &#x2F;&#x2F; 修改了声明的位置</span><br><span class="line">    for (i &#x3D; 0; i &lt; param-&gt;len; i++) &#123;</span><br><span class="line">        if (param-&gt;arr[i] &#x3D;&#x3D; MATCH_FLAG) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    HandleMatchedCount(param, data, count);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">int CountMatchedParam(Context context, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    Session session &#x3D; NULL;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Data* data &#x3D; NULL;</span><br><span class="line">    if (IsParamValid(context, prarm) !&#x3D; TRUE) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    session &#x3D; GetSession(context); &#x2F;&#x2F; session通过函数返回值获取</span><br><span class="line">    if (session &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    data &#x3D; (Data*)MALLOC(sizeof(Data));</span><br><span class="line">    if (data &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    HandleExceptionMatch(session, param, &amp;count); &#x2F;&#x2F; 这里用到了session；同时由于修改了count的值，且在后续用到了，所以这里传递了它的地址</span><br><span class="line">    if (MatchProcess(param, data, count) !&#x3D; OK) &#123; &#x2F;&#x2F; count后续不再使用，所以直接传递即可</span><br><span class="line">        SAFE_FREE(data);  &#x2F;&#x2F; data在哪个函数里申请，就在哪个函数里释放，方便统一维护</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们关注下原<strong>CountMatchedParam</strong>函数中的<strong>i</strong>和<strong>conn</strong>，由于他们只在提炼后的函数中使用，所以修改了其声明的位置；</p>
<p>其次，对于<strong>GetSession</strong>函数中用到的<strong>context</strong>，直接通过入参传递了进去；</p>
<p>同时，在<strong>GetSession</strong>函数中，由于修改了<strong>session</strong>的值，且在后面会继续用到它，所以通过返回值将其传递了出来；</p>
<p>而<strong>count</strong>变量有2处值得注意的地方：首先，在<strong>HandleExceptionMatch</strong>中修改了它的值，且后续会继续使用它，所以传入的是它的地址；其次，在<strong>MatchProcess</strong>之后不再使用<strong>count</strong>，所以直接传递进去就行了；</p>
<p>最后，<strong>data</strong>这个局部变量是在<strong>CountMatchedParam</strong>函数内申请的，那么在<strong>MatchProcess</strong>内部处理的时候，就需要把释放的方法放到被调函数里，也就是<strong>CountMatchedParam</strong>里。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-小心宏定义"><a href="#1-小心宏定义" class="headerlink" title="1. 小心宏定义"></a>1. 小心宏定义</h4><p>如果宏定义里有return之类的跳转或返回语句，一定要小心，不要因为提取函数而误改了原有的流程。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define PRE_CHECK(a) \</span><br><span class="line">    if (a &#x3D;&#x3D; NULL) &#123; \</span><br><span class="line">        return -1;   \ &#x2F;&#x2F; 要小心这里有个return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">int foo(Param param)</span><br><span class="line">&#123;</span><br><span class="line">    PRE_CHECK(param);</span><br><span class="line">    if (param-&gt;flag &#x3D;&#x3D; ERR_FLAG) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ... other process</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PRE_CHECK这个宏定义的代码段里，有一个return语句，如果不小心提了出去，则很容易破坏原有函数的逻辑。不过在宏定义里写return语句也的确不是一个好的编程习惯。</p>
<h4 id="2-数组形参要传长度"><a href="#2-数组形参要传长度" class="headerlink" title="2. 数组形参要传长度"></a>2. 数组形参要传长度</h4><p>将数组作为入参时，如果在函数内要使用它的长度，那么一定要通过入参传进去，否则你不仅会得到一个编译告警，还会发现根本得不到入参数组的实际长度。</p>
<blockquote>
<p>warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘char *’ [-Wsizeof-array-argument]</p>
</blockquote>
<h4 id="3-指针传参问题"><a href="#3-指针传参问题" class="headerlink" title="3. 指针传参问题"></a>3. 指针传参问题</h4><p>指针传参问题是新手最容易遇到的问题，当然理解了之后也比较容易解决。我们还是用例子来说明。<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ErrCode GetRequiredInfo(Context context, Session* session, char* sid)</span><br><span class="line">&#123;</span><br><span class="line">    Connection *conn &#x3D; NULL;</span><br><span class="line">    conn &#x3D; GetConnection(context);</span><br><span class="line">    if (conn &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    session &#x3D; GetSessionFromConn(conn);</span><br><span class="line">    if (session &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    sid &#x3D; GetSidFromSession(session);</span><br><span class="line">    if (sid &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">ErrCode GetReport(Context context, char *sid, Report **report)</span><br><span class="line">&#123;</span><br><span class="line">    *report &#x3D; ParseReport(context, sid);</span><br><span class="line">    if (report &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">int HandleData(Context context, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    Session *session &#x3D; NULL;</span><br><span class="line">    char *sid &#x3D; NULL;</span><br><span class="line">    Report *report &#x3D; NULL;</span><br><span class="line">    ErrCode ret &#x3D; ERROR;</span><br><span class="line">    ret &#x3D; GetRequiredInfo(context, session, sid);</span><br><span class="line">    if (ret !&#x3D; OK) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &#x3D; GetReport(context, sid, &amp;report);</span><br><span class="line">    if (ret !&#x3D; OK) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ... other process</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子里有3处新手常常容易犯的错误：</p>
<ol>
<li>在<strong>GetRequiredInfo</strong>函数里，<strong>session</strong>被重新赋值了，而如果在<strong>HandleData</strong>里要继续使用它，那么就一定会拿到一个空的值；因为C语言的函数是值传递的，指针也是拷贝复制的，对形参的修改不会影响实参；所以这里应该传递二级指针。</li>
<li>同样在<strong>GetRequiredInfo</strong>函数里，<strong>sid</strong>也犯了同样的错误，也要传二级指针。</li>
<li>第3个错误发生在<strong>GetReport</strong>函数里，因为修改了<strong>report</strong>的值，所以传递了二级指针，并通过解引用来赋值，这是正确的；但是在第21行发生了一个错误，本意应该是要判断<strong>*report</strong>是否为空，却误判成了<strong>report</strong>，它本身虽然是NULL，但是空指针的指针却不是NULL，所以这个逻辑判断永远都会返回成立，起不到实际想要的效果。</li>
</ol>
<p>正确的修改应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ErrCode GetRequiredInfo(Context context, Session** session, char** sid)</span><br><span class="line">&#123;</span><br><span class="line">    Connection *conn &#x3D; NULL;</span><br><span class="line">    conn &#x3D; GetConnection(context);</span><br><span class="line">    if (conn &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *session &#x3D; GetSessionFromConn(conn);</span><br><span class="line">    if (*session &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *sid &#x3D; GetSidFromSession(*session);</span><br><span class="line">    if (*sid &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">ErrCode GetReport(Context context, char *sid, Report **report)</span><br><span class="line">&#123;</span><br><span class="line">    *report &#x3D; ParseReport(context, sid);</span><br><span class="line">    if (*report &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">int HandleData(Context context, Param param)</span><br><span class="line">&#123;</span><br><span class="line">    Session *session &#x3D; NULL;</span><br><span class="line">    char *sid &#x3D; NULL;</span><br><span class="line">    Report *report &#x3D; NULL;</span><br><span class="line">    ErrCode ret &#x3D; ERROR;</span><br><span class="line">    ret &#x3D; GetRequiredInfo(context, &amp;session, &amp;sid);</span><br><span class="line">    if (ret !&#x3D; OK) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &#x3D; GetReport(context, sid, &amp;report);</span><br><span class="line">    if (ret !&#x3D; OK) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ... other process</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-free之后的赋空"><a href="#4-free之后的赋空" class="headerlink" title="4. free之后的赋空"></a>4. free之后的赋空</h4><p>释放动态分配的内存后，指向这块内存的指针一定要赋空，否则会引入一些意想不到的问题。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Deinit()</span><br><span class="line">&#123;</span><br><span class="line">    if (g_session_data-&gt;report_list !&#x3D; NULL) &#123;</span><br><span class="line">        free(g_session_data-&gt;report_list);</span><br><span class="line">        g_session_data-&gt;report_list &#x3D; NULL; &#x2F;&#x2F; 这句不能少</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中的函数释放了全局变量中的<strong>report_list</strong>，并在释放后将其赋空。如果这里缺少了赋空的操作，那么在程序的其他地方如果使用到了这个变量，则很容易访问非法内存，篡改数据，带来意想不到的问题。</p>
<h4 id="5-注意返回值"><a href="#5-注意返回值" class="headerlink" title="5. 注意返回值"></a>5. 注意返回值</h4><p>返回值会影响代码的执行逻辑，在提炼函数时，如果被提炼出来的函数包含了返回值，则一定要确保提炼出去之后，原函数的逻辑不能改变。</p>
<p>同时，也要小心在提炼出来的函数里当你想要自定义一个返回值的时候，不要和原返回值所定义的宏相重复了，否则就会篡改原来的逻辑。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define RET_ERROR -1</span><br><span class="line">#define RET_ERROR_SEC -2</span><br><span class="line">void foo(Status status)</span><br><span class="line">&#123;</span><br><span class="line">    if (status &#x3D;&#x3D; LASTING) &#123;</span><br><span class="line">        &#x2F;&#x2F; process...</span><br><span class="line">        return RET_ERROR;</span><br><span class="line">    &#125; else if (status &#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        &#x2F;&#x2F; process...</span><br><span class="line">        return RET_ERROR_SEC;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; process...</span><br><span class="line">        return -2; &#x2F;&#x2F; 本想返回一个其他类型的错误码，却与RET_ERROR_SEC重复了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h2><p>圈复杂度作为一个衡量软件复杂度的指标，它的确提供了一个可以度量代码质量的方法，便于监控和管理，但是圈复杂度高的代码就一定是不好的吗？</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void TimerHandler(Msg msg)</span><br><span class="line">&#123;</span><br><span class="line">    switch (msg) &#123;</span><br><span class="line">        case RESTART:</span><br><span class="line">            ProcessRestart();</span><br><span class="line">            break;</span><br><span class="line">        case UPDATE_CFG:</span><br><span class="line">            ProcessUpdateCfg();</span><br><span class="line">            break;</span><br><span class="line">        case NEW_BACKUP:</span><br><span class="line">            ProcessNewPackup();</span><br><span class="line">            break;</span><br><span class="line">        case OPEN_FLAG:</span><br><span class="line">            ProcessOpenFlag();</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;&#x2F; ....other cases but not too many</span><br><span class="line">        default:</span><br><span class="line">            Log(ERROR, &quot;unknown message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这样的代码不管是从可读性还是可维护性的角度来讲都是可以接受的，当然你也可以按照表驱动的方式去重构它，但是如果不动它，也没有什么问题，反而如果表驱动用的不好，到是会引入其他的问题。</p>
<p>类似的例子还有不少，我就不一一举例了，我想说的是，圈复杂度其实只能代表圈复杂度本身，并不能完全描述代码的质量和可维护性等特性，只能作为一个侧面的参考。代码是给人看的，是人来维护的，关键在于在功能正确的前提下，怎么把代码写的让人容易看懂，容易维护。圈复杂度低的代码往往逻辑简洁，好读、好测、可控，同时，一些圈复杂度高的代码也可能拥有同样的特点，反而你想尽办法把它的圈复杂度降下去了之后却发现更难维护了。所以，当我们在讨论圈复杂度的时候，一定要清楚我们到底在讨论什么。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/01/2020-01-23-cyclomatic-complexity-in-c/" data-id="ck630batz000evchl4bsr7lm1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/01/hello-world/" class="article-date">
  <time datetime="2020-02-01T02:24:48.604Z" itemprop="datePublished">2020-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/01/hello-world/" data-id="ck62ztewk00002khl1kinf7t7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/01/2019-12-29-stay-serious/">保持敬畏，保持严谨</a>
          </li>
        
          <li>
            <a href="/2020/02/01/2019-12-01-c-understanding-value-passing/">深入理解C语言的值传递</a>
          </li>
        
          <li>
            <a href="/2020/02/01/2018-08-19-internet-of-value/">Internet of Value</a>
          </li>
        
          <li>
            <a href="/2020/02/01/2018-07-08-about-working-overtime/">过度加班百害而无一利</a>
          </li>
        
          <li>
            <a href="/2020/02/01/2017-05-03-understandable-computer-science/">白话计算机科学</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 LiAng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>